---
title: "双11凑单问题 - 动态规划的使用"
date: 2023-06-23T11:26:08+08:00
tags:
- 算法
description: "从状态表解决动态规划很简单，但并不是所有动态规划问题都能用状态表解决"
images:
- dynamic-buy-11/img.png
---

## 问题描述

假设我们有一个购物车，里面有 `n` 件商品（价格已知）。我们需要从这 `n` 件商品中挑选出一些商品，使得它们的总价刚好满足满减要求的价格。例如，满减要求是 **10元**。

简化后的例子：
- 商品价格数组为 `[2, 2, 4, 6, 3]`
- 满减要求为 **10元**

目标是从这些商品中选出一些，使得它们的总价尽可能接近满减要求（即 **10元**），但不超过 **3倍满减金额**（即 **30元**）。

---

## 解决思路

这个问题可以类比于经典的 **背包问题**，即在给定的最大重量限制下，选择物品以最大化总价值。这里的“最大重量”对应于满减金额的上限（如 **30元**），而“物品的价值”对应于商品的价格。

### 常规解法：回溯思想
最直接的解法是通过列出所有可能的商品组合，然后找到满足条件的组合。然而，这种方法的时间复杂度是指数级的（O(2^n)），当商品数量较多时，计算效率会非常低。

### 优化解法：动态规划
我们可以借鉴背包问题的动态规划思想，避免状态的指数级增长。具体来说：
1. 使用一个二维状态表 `states` 来记录每一步的状态。
2. 每个状态 `states[i][j]` 表示前 `i` 件商品能否凑出总价为 `j` 的组合。
3. 通过状态转移方程，逐步推导出最终结果。

---

## 动态规划算法详解

### 状态定义
- `states[i][j]`：表示前 `i` 件商品是否能凑出总价为 `j` 的组合。
- 初始状态：`states[0][0] = true`（不选任何商品时，总价为 0 是可行的）。
- 如果第 `i` 件商品的价格 `items[i]` 小于等于当前总价 `j`，则可以通过选择或不选择该商品来更新状态。

### 状态转移方程
1. **不选择第 `i` 件商品**：
   - 如果 `states[i-1][j] = true`，则 `states[i][j] = true`。
2. **选择第 `i` 件商品**：
   - 如果 `states[i-1][j-items[i]] = true`，则 `states[i][j] = true`。

### 边界条件
- 总价不能超过 **3倍满减金额**（即 `3 * w`）。
- 如果找不到满足条件的组合，则返回空结果。

---

## 实现代码

以下是基于上述思路的 JavaScript 实现：

```js
/**
 * 双11凑单问题
 * @param {number[]} items 商品价格数组
 * @param {number} n 商品个数
 * @param {number} w 凑单金额
 */
function double11advance(items, n, w) {
    // 初始化状态表
    let states = new Array(n);
    for (let i = 0; i < n; i++) {
        states[i] = new Array(3 * w + 1).fill(false);
    }

    // 初始状态
    states[0][0] = true; // 不选第一个商品
    if (items[0] <= 3 * w) {
        states[0][items[0]] = true; // 选第一个商品
    }

    // 动态规划填表
    for (let i = 1; i < n; i++) {
        // 不选择第 i 件商品
        for (let j = 0; j <= 3 * w; j++) {
            if (states[i - 1][j] === true) {
                states[i][j] = states[i - 1][j];
            }
        }

        // 选择第 i 件商品
        for (let j = 0; j <= 3 * w - items[i]; j++) {
            if (states[i - 1][j] === true) {
                states[i][j + items[i]] = true;
            }
        }
    }

    // 找到最接近满减金额的总价
    let j;
    for (j = w; j < 3 * w + 1; j++) {
        if (states[n - 1][j] === true) {
            break;
        }
    }

    // 如果找不到满足条件的组合
    if (j === 3 * w + 1) {
        console.log("无法找到满足条件的商品组合");
        return;
    }

    // 回溯找出具体选择了哪些商品
    for (let i = n - 1; i >= 1; i--) {
        if (j - items[i] >= 0 && states[i - 1][j - items[i]] === true) {
            console.log(items[i]); // 打印已选商品
            j -= items[i];
        }
    }

    // 检查是否选择了第 0 件商品
    if (j !== 0) {
        console.log(items[0]);
    }
}
```

---

## 示例运行

### 输入
```js
const items = [2, 2, 4, 6, 3];
const n = items.length;
const w = 10;

double11advance(items, n, w);
```

### 输出
```
6
4
```

解释：选择价格为 `6` 和 `4` 的商品，总价为 `10`，刚好满足满减要求。

---

## 复杂度分析

1. **时间复杂度**：
   - 填表过程需要遍历每个商品和每个可能的总价，时间复杂度为 O(n * 3w)，其中 `n` 是商品数量，`w` 是满减金额。
2. **空间复杂度**：
   - 使用了一个二维数组 `states`，空间复杂度为 O(n * 3w)。

---

## 总结

通过动态规划的方法，我们将原本指数级复杂度的问题优化为多项式复杂度，大大提高了计算效率。同时，这种方法具有通用性，可以应用于类似的组合优化问题，如背包问题、硬币找零等。
