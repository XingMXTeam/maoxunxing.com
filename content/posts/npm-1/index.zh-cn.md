---
title: "pnpm vs npm"
description: "什么是幽灵依赖问题"
date: 2024-09-10
tags:
  - NPM
images:
  - npm-1/npm.webp
---

## 什么是幽灵依赖？
**幽灵依赖（Ghost Dependencies）** 是指项目中使用了未在 `package.json` 中明确声明的依赖。这种情况通常发生在 npm 和 Yarn 中，因为它们的扁平化依赖结构允许访问未直接声明的包。

### 示例
假设你的项目直接依赖 `express`：
```json
{
  "dependencies": {
    "express": "4.17.1"
  }
}
```
`express` 依赖于 `body-parser`，因此 `body-parser` 也会被安装到 `node_modules` 中。

在你的代码中，你可以直接使用 `body-parser`，尽管没有在 `package.json` 中声明它：
```javascript
const bodyParser = require('body-parser');
```

这段代码能够运行，但 `body-parser` 实际上是一个 **幽灵依赖**。

### 存在的问题
1. **可靠性问题**  
   如果未来 `express` 不再依赖 `body-parser`，你的代码可能会突然崩溃。
   
2. **版本不一致**  
   不同的开发者可能安装不同版本的依赖，导致项目行为不一致。

3. **维护困难**  
   幽灵依赖让项目的依赖关系变得模糊，增加了维护成本。

---

## pnpm 解决的问题

pnpm 通过严格的依赖树结构和优化的存储机制，解决了传统包管理工具（如 npm 和 Yarn）中的许多问题，包括幽灵依赖问题。

### 1. 磁盘空间效率
- **特点**：pnpm 使用硬链接和符号链接来共享包，避免重复安装相同的包。
- **解决的问题**：减少了磁盘空间的使用，尤其是在大型项目中效果显著。

### 2. 安装速度
- **特点**：pnpm 通常比 npm 更快，特别是在安装大型项目依赖时。
- **解决的问题**：加快了项目的初始设置和依赖更新过程，提高了开发效率。

### 3. 依赖管理
- **特点**：pnpm 使用严格的依赖树结构，只允许访问明确声明的依赖。
- **解决的问题**：消除了“幽灵依赖”问题，提高了项目的可靠性和可维护性。

### 4. 单一存储
- **特点**：pnpm 在系统中维护一个集中的包存储（全局存储），所有项目共享这些包。
- **解决的问题**：进一步节省磁盘空间，同时加快了多个项目的包安装速度。

### 5. 并行安装
- **特点**：pnpm 默认并行安装包，充分利用多核 CPU 的性能。
- **解决的问题**：减少了大型项目的依赖安装时间，提升了安装效率。

### 6. 更好的锁文件
- **特点**：pnpm 的锁文件（`pnpm-lock.yaml`）更加简洁且易于版本控制。
- **解决的问题**：改善了团队协作和版本一致性，确保不同环境下的依赖安装结果一致。

---

## 总结

pnpm 通过以下方式显著改进了依赖管理：
1. **消除幽灵依赖**：严格的依赖树结构确保项目只能访问明确声明的依赖。
2. **提高效率**：通过硬链接、符号链接和并行安装，减少了磁盘空间占用和安装时间。
3. **增强可靠性**：单一存储和更好的锁文件机制，确保依赖的一致性和可维护性。

尽管 pnpm 可能需要更多的初始设置工作，但它带来的长期收益（如更高的可靠性和更低的资源消耗）使其成为现代 JavaScript 项目中值得推荐的包管理工具。