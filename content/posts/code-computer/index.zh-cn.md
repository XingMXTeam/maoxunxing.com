---
title: "[WIP] 计算机本质的理解"
date: 2021-08-24
tags:
  - 操作系统
description: "计算机本质是什么？"
images:
  - code-computer/code-computer.jpeg
---

## 编码原理

> 计算机本质是 0/1 的世界，如果用 0/1 表达这个世界。结论是：需要通过编码。

### 数字编码

> 首先是怎么表达数字

**为什么会有补码？**

> 补码是为了方便计算机的运算, 计算机比较容易做加法

**举个例子**： 5+（-3）通过补码（定义：正数不变，负数取反并且+1）计算  
步骤 1: 0101（5）  
步骤 2: 0011（3） -> 取反 1100 ->加一 1101  
步骤 3: 0101+1101=100010 截断后 0010（-2）  
运算的结果符合人类的预期结果， 而原码（首位为符号位） 反码（除了符号位，所有位取反） 计算出来的结果都不满足人类预期。

**为什么表示范围是[-128, 127] ?**

> 这个问题之前一直困扰着我

举个例子来说明：
4 位二进制补码表示是：  
0000（-0） 0000（0）  
1111（-1) 0001（1）  
1110 (-2) 0010（2）  
... ...  
1011(-5) 0101（5）  
1010(-6) 0110（6）  
1001(-7) 0111（7）

范围是 [-7, 7] 1000 没有被表示，刚好拿来表示-8（-8 的补码表示： 1000（原） -> 取反 0111 -> 加一 1000）  
所以最终是[-8, 7]。 同理[-128,127]也解释得通。

<!-- **为什么补码要反码+1？**
4位二进制补码表示：
0000（-0） 0000（0）
1111（-1)  0001（1）
1110 (-2)  0010（2）
...       ...
1011(-5)   0101（5）
1010(-6)   0110（6）
1001(-7)   0111（7）

+1后，0位表示一致，并且符号位参与运算刚好符合预期 -->

**为什么小数会有精度问题？**

> 在一些语言中，0.1+0.2 永远不会等于 0.3 为什么？

简单举个例子：  
因为二进制的小数只能用固定的数字组合，比如 0.2，无法用二进制组合精确表示

### 文本编码

> 数字编码后，文本是不是也要通过编码？

编码主要是通过如码表来实现的，也就是字符和数字的对应关系。

码表（字符集）： 字符和数字的对应关系 （接口）
字符编码： 具体实现
码点： 表中的每个数字（可能由一个或者多个码元组成）

**发展轨迹**：  
ASCII(英文和特殊字符) : 一个字节中的 7 位 -> EASCII 字符集： ISO 8859-1 -> GB2312 -> GBK： GBK 编码（汉字） -> GB18030 -> Unicode 字符集 ：一般 unicode 编码指 UTF-16 编码 变长编码、2 字节码元、有字节序问题， UTF-8 是变长编码 单字节码元 无字节序问题

初始化->本地化（GB 表示国标）->国际化->效率化

### 多媒体编码

音频： 一定时间内采集有限的样本表示。 采样率和模拟信号频率有关，每秒 40000 个样本 编码方式 AAC
图像： 光栅图（解析度： 单位面积像素数，色彩深度： 像素位数量）/矢量图（数学公式计算像素分布）
视频： 帧 由图片构成，多帧构成视频流。 编码方式 MPEG-1, MPEG-2, MPEG-4, H.264, H.265

## 运算的本质

> 有了编码后，计算机如何实现计算呢？为什么内存条、芯片会很贵？

### 概念

逻辑运算中的与、或、非、异或

通过逻辑模拟可以实现以上的逻辑运算。输入是开关，输出一般是 LED 灯(有颜色的灯)。芯片一般是实现逻辑运算，比如 7486（异或门）芯片，会暴露一些引脚出来，比如一个接电源，一个接地，其他接输入，表示输出等

### 半加器：不考虑进位， 单位

Cout = X \* Y
S = X ⊕ Y

### 全加器: 考虑进位， 单位

```
S = X ⊕ Y ⊕ Cin
// both the X and Y values are true, or if either the X or Y value is true and the Cin is true
Cout = (X*Y) + ((X⊕Y)*Cin)
```

### 两位加法机

### 多位加法机

### 记忆加法机

保存上次计算的结果

### 选择加法机

多弄几个记忆加法器，避免输错时重新来过。

### 自动加法机

按一下开关，自动自动输入并且把所有数字加起来。

### 自由加法机

可控制只计算部分的数字

### 对比现代计算机

目前的计算机能进行 10 亿次的加法运算。计算机包含
1 存储器（存储箱：用于存储输入的数字，要执行的代码，计算的结果）
2 运算器（累加器：计算两个数字相加）
3 控制器（控制板：切换开关）
4 输入设备（输入面板：输入开关）
5 输出设备（输出灯泡：灯泡现实输出数据）

以上包含了：输入、输出、内存、寻址、译码、指令、算术逻辑单元等概念

<!--
键盘输入数字->产生电压（高低电平 信号？） 触发输入总线中断程序->数字输入到内存区域，同时分配内存地址。 而加法机在操作输入面板每输入一个数字，需要通过选择器制定记忆盒子来存储数组，记忆盒子的编号对应了选择器的序号，也就是内存地址

计算机加法按键，计算机会将数字所在内存地址加载到CPU进行加法运算。加法机需要写代码到记忆盒子，第一行是加法操作代码，第二三行是地址编码。编码完成后，启动异步计数器（周期性扫描记忆盒子的代码），逐行执行，异步计数器执行完后，记忆盒子的数据就被加载到累加器。数据通过寻址（通过译码器寻址数据记忆盒子的过程称为寻址过程）传输到累加器运算后存储到锁存器盒子，然后通过灯泡显示出来。

 -->

编程就是把一系列指令存到内存，让计算机逐步执行这些指令。把一些常用指令封装起来就形成了操作系统。

### 虚拟电路模拟

https://exp.xiaogd.net/circuitjs1-zh/circuitjs.html

### 解释器和编译器的区别

> 我们的程序是怎么跑起来的？

代码在执行前都需要通过语法解析器，将输入的代码字符串转换为 AST(抽象语法树)

一般解释器解释执行程序时会经过如下步骤：  
1 Lexer（词法分析器）读取代码，将代码转换为 token 序列  
2 Parser(语法分析器) 把读到的 Token 序列转换为 AST（大部分情况 Lexer 是 Parser 的一部分）  
3 对 AST 进行 Lowering(化简 AST)或者 Desugar(把语法糖的 AST 节点转换为标准等价 AST 节点)  
4 Interpreter 递归执行 AST

解释器直接解释执行 AST，并返回最终结果：

```js
function interpret(ast) {
  switch (ast.type) {
    case "number":
      return ast.value;
    case "negative":
      return -interpret(ast.value);
    case "op":
      switch (ast.value) {
        case "+":
          interpret(ast.v1) + interpret(ast.v2);
      }
  }
}
```

编译器: 把 AST 翻译成目标语言，比如汇编

```js
// 假定为目标机器为栈式虚拟机，然后通过exec函数执行
function compile(ast) {
  switch (ast.type) {
    case "number":
      return "ds.push(" + ast.value + ")\n";
    case "negative":
      return "ds.push(-ds.pop())\n";
    case "op":
      return (
        compile(ast.v1) +
        compile(ast.v2) +
        "ds.push(ds.pop() " +
        ast.value +
        "  ds.pop())\n"
      );
  }
}
```

将 ast 的遍历和实现分离，每一步操作封装为单独的函数

```js
function interpret(ast) {
  switch (ast.type) {
    case "number":
      return ast.value;
    case "negative":
      return -interpret(ast.value);
    case "op":
      switch (ast.value) {
        case "+":
          interpret(ast.v1) + interpret(ast.v2);
      }
  }
}
```

## 代码的本质

通过代码控制机器，代码是人阅读的指令。 主要有两大要素数据和操作（判断、选择、循环、分支等）。

### 内存模型

> 计算机是怎么存储的？

[运算的本质](#运算的本质)的锁存器（64 位构成的庞大数组），本质就是内存。

顺序执行： 代码编译成一条条指令还在到内存（操作系统分配的执行区域），计数器逐步执行内存的执行，返回结果

分支选择： 跳到对应地址执行指令

嵌套执行： 函数执行会在内存开辟一组连续的内存空间。 函数代码执行前根据参数数量、参数大小，计算分配栈空间，栈底为内存高地址方向
执行过程的活动记录，由标记顶部位置的帧指针和标记底部位置的栈指针定义。当执行完毕，帧指针指向下一条指令地址
