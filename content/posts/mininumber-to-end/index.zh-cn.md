---
title: "Minimum number of jumps to reach end"
date: 2022-04-16T22:29:56+08:00
tags:
  - 算法
description: "数组移动"
images:
  - mininumber-to-end/test.png
---

## 问题描述

给定一个整数数组，其中每个元素表示从该位置可以向前跳的最大步数。编写一个函数返回到达数组末尾所需的最小跳跃次数。如果某个元素为 `0`，则无法通过该元素。如果无法到达终点，则返回 `-1`。

### 示例 1
输入：
```text
arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9}
```
输出：
```text
3
```
解释：  
- 第 1 次跳跃：从索引 `0` 跳到索引 `1`（因为 `arr[0] = 1`）。
- 第 2 次跳跃：从索引 `1` 跳到索引 `4`（因为 `arr[1] = 3`，可以选择跳到索引 `2`、`3` 或 `4`）。
- 第 3 次跳跃：从索引 `4` 跳到索引 `10`（因为 `arr[4] = 9`，直接跳到终点）。

### 示例 2
输入：
```text
arr[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
```
输出：
```text
10
```
解释：每次只能跳一步，因此需要 10 次跳跃才能到达终点。

---

## 解答

### 方法 1：贪心算法（优化版暴力解法）

#### 实现代码
```ts
function miniJumpsToEnd(arr) {
  const n = arr.length;

  // 如果数组长度为 1 或更小，无需跳跃
  if (n <= 1) return 0;

  // 如果起点为 0 且数组长度大于 1，无法跳跃
  if (arr[0] == 0) return -1;

  let maxReach = arr[0]; // 当前能够到达的最远索引
  let step = arr[0];     // 当前剩余的步数
  let jumps = 1;         // 总跳跃次数

  for (let i = 1; i < n; i++) {
    // 如果当前索引已经到达或超过终点
    if (i == n - 1) {
      return jumps;
    }

    // 更新能够到达的最远索引
    maxReach = Math.max(maxReach, i + arr[i]);

    // 消耗一步
    step--;

    // 如果当前剩余步数为 0，需要进行一次跳跃
    if (step == 0) {
      jumps++;

      // 如果当前索引已经超过最大可达范围，说明无法到达终点
      if (i >= maxReach) {
        return -1;
      }

      // 更新剩余步数为新的最大可达范围减去当前索引
      step = maxReach - i;
    }
  }

  return -1; // 如果循环结束仍未返回结果，说明无法到达终点
}
```

---

### 算法解析

1. **核心思想**  
   使用贪心算法动态维护三个变量：
   - `maxReach`：记录当前能够到达的最远索引。
   - `step`：记录当前剩余的步数。
   - `jumps`：记录总的跳跃次数。

2. **流程**
   - 遍历数组时，更新 `maxReach` 为当前索引加上当前元素值的最大值。
   - 每次消耗一步（`step--`），当 `step` 为 `0` 时，表示需要进行一次跳跃，并更新剩余步数。
   - 如果当前索引超过了 `maxReach`，说明无法继续前进，返回 `-1`。

3. **边界条件**
   - 如果数组长度为 `1`，直接返回 `0`。
   - 如果起点为 `0` 且数组长度大于 `1`，直接返回 `-1`。

---

### 时间复杂度与空间复杂度

- **时间复杂度**：  
  只需遍历数组一次，因此时间复杂度为 **O(n)**。

- **空间复杂度**：  
  只使用了常量级额外空间，因此空间复杂度为 **O(1)**。

---

### 示例运行

#### 示例 1
输入：
```text
arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9}
```
执行过程：
- 初始状态：`maxReach = 1`, `step = 1`, `jumps = 1`
- 遍历到索引 `1`：更新 `maxReach = 4`, 消耗 `step`，进行第 2 次跳跃。
- 遍历到索引 `4`：更新 `maxReach = 13`, 消耗 `step`，进行第 3 次跳跃。
- 到达终点，返回 `3`。

输出：
```text
3
```

#### 示例 2
输入：
```text
arr[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
```
执行过程：
- 每次只能跳一步，总共需要 10 次跳跃。

输出：
```text
10
```

---

### 总结

该算法通过贪心策略实现了高效的跳跃计算，时间复杂度为 **O(n)**，空间复杂度为 **O(1)**。它适用于解决类似“最少跳跃次数”的问题，尤其在数组规模较大时表现优异。