---
title: "计算机体系学习"
date: 2019-11-25
tags:
  - 计算机
custom_toc:
  - title: "解谜计算机科学读后感"
  - title: "读王垠博客后有感"
  - title: "云原生"
  - title: "DNS"
  - title: "文件系统-Blob模式"
  - title: "Linux"
  - title: "函数式编程"
  - title: "TCP"
---

## 解谜计算机科学读后感

- **核心观点**  
  > 让自己相信：我已经掌握了整个学科，只不过掌握的都是精华的原理。  

- **关键点**  
  - 学科的核心是原理，而非琐碎的细节。  
  - 理解符号、模型和计算的本质，能够帮助建立全局视角。  

## **2. 符号与模型**

- **符号**  
  - 符号就是符号，例如 `1, 2, 3`，它们本身没有意义，只是表示某种抽象概念的工具。  

- **模型**  
  - 模型是一种可操作的东西，能够表达符号背后的逻辑和关系。  

- **从符号到模型的过程**  
  - 这一过程称为 **语法分析**，即通过解析符号的结构，构建出对应的模型。  

- **计算图**  
  - 计算图是一种抽象的图示方法，用于表达计算的过程，体现数据流动的路径。  
  - **技巧**：看到符号时，尝试想象出画面，理解符号背后的模型。  

## **3. 思维方式**

- **不要固化你的思维方式**  
  - 开放心态，灵活思考，避免被单一模式限制。  

## **4. 核心概念**

### **4.1 表达式**
- 表达式是由符号组成的规则集合，用于描述计算的逻辑。  

### **4.2 变量**
- 变量是一种表示中间过程的工具，用来存储和传递信息。  

### **4.3 编译**
- **定义**：将一段代码翻译成另一种等价形式的过程。  
- **特点**：编译后的代码通常由简单指令组成，能够高效完成任务。  

### **4.4 并行计算**
- **定义**：在时间上重叠的计算方式。  
- **优点**：提高计算效率。  
- **缺点**：可能带来通信开销，或因计算单元能力不同导致性能瓶颈。  

### **4.5 函数**
- **定义**：具有未知数作为输入的构造体，称为函数。  
- **作用**：函数是计算的基本单元，用于封装逻辑和操作。  

### **4.6 计算**
- **本质**：计算就是机械化的信息处理。  


### 路由器收敛时间

**路由器收敛时间（Convergence Time）** 是指网络中的所有路由器完成路由信息同步并达到一致状态所需的时间。换句话说，当网络拓扑发生变化（如链路故障、设备重启或新增链路）时，路由器需要重新计算最佳路径并将这些变化传播到整个网络。直到所有路由器都更新了它们的路由表并达成一致状态，这个过程才被视为完成。

---

## 读王垠博客后有感

在讨论计算机科学的本质时，许多人习惯性地将数学视为其核心基础。然而，这种观点并不完全准确。以下是对这一主题的深入探讨。

## 1. 数学并非计算机科学的唯一基础

### 1.1 计算机的本质是工具

- **多功能性**：计算机并不仅仅是一个解决数学问题的工具，它还可以用于处理各种非数学领域的问题，例如：
  - 数据分析
  - 图形渲染
  - 自然语言处理
  - 游戏开发
- **跨学科应用**：计算机科学的应用范围远远超出了数学的范畴，涵盖了工程、艺术、社会科学等多个领域。

### 1.2 数学的作用有限

- **工具而非核心**：虽然数学在某些计算机科学领域（如算法设计、密码学）中扮演了重要角色，但它并不是所有计算机应用的基础。
- **其他学科的重要性**：逻辑学、语言学、心理学等学科同样对计算机科学的发展产生了深远影响。

## 2. 难以理解的问题：可能是设计问题

### 2.1 设计问题的核心

- **复杂性来源**：许多看似难以理解的问题，实际上可能源于系统设计的不合理，而非数学本身的复杂性。
- **用户体验优先**：一个优秀的系统设计应该注重用户的理解和使用体验，而不是过度依赖复杂的数学模型。

### 2.2 优化设计的方法

- **模块化思维**：将复杂问题分解为多个简单的子问题，分别解决后再整合。
- **抽象与简化**：通过抽象和简化，隐藏不必要的细节，使系统更易于理解和维护。
- **迭代改进**：不断测试和优化设计，确保系统的易用性和效率。

## 3. 计算机科学的核心：解决问题的能力

### 3.1 多样化的应用场景

- **超越数学**：计算机科学的核心在于如何利用计算机这一工具，解决实际问题，而不仅仅是数学问题。
- **创新与实践**：无论是开发新的软件，还是优化现有系统，计算机科学都强调创新能力和实践能力。

### 3.2 跨学科融合

- **多学科协作**：计算机科学的成功往往依赖于与其他学科的合作，例如生物学（生物信息学）、物理学（模拟与建模）等。
- **综合能力**：掌握多种技能（编程、设计、沟通等）比单纯精通数学更能推动计算机科学的发展。

---

## 云原生

| 概念                    | 解释                                                                                                                               | 其他             |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| **云原生**              | 适用于云计算的架构理念，实践云原生技术理念的应用或者业务可以最大化享受云计算的技术红利，包括弹性计算、按量计费、无厂商绑定、高 SLA |                  |

- **补充说明**:  
  - **弹性计算**: 根据业务需求动态调整资源分配，提升效率并降低成本。  
  - **按量计费**: 按实际使用量付费，避免资源浪费。  
  - **无厂商绑定**: 避免对特定云服务提供商的依赖，增强灵活性。  
  - **高 SLA (Service Level Agreement)**: 提供高可用性和可靠性保障。

## 2. 云计算时代

| 概念                    | 解释                                                                                                                               | 其他             |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| **云计算时代**          | 以计算为中心，存储、网络、计算三大件                                                                                               |                  |

- **补充说明**:  
  - **存储**: 数据的持久化和管理，支持分布式存储技术。  
  - **网络**: 提供高效的通信和数据传输能力，支持虚拟化网络技术。  
  - **计算**: 核心处理能力，支持弹性扩展和高性能计算。

## 3. 云原生技术

| 概念                    | 解释                                                                                                                               | 其他             |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| **云原生技术**          | 容器、声明式 API、不可变基础设施、服务网络、Serverless                                                                             |                  |

- **技术详解**:  
  - **容器**: 如 Docker 和 Kubernetes，提供轻量级的虚拟化环境，便于应用的部署和管理。  
  - **声明式 API**: 通过配置文件定义系统状态，简化管理和自动化操作。  
  - **不可变基础设施**: 基础设施一旦部署后不再修改，通过重新部署新版本来更新，确保一致性。  
  - **服务网络**: 如 Istio，提供微服务之间的通信、监控和安全性保障。  
  - **Serverless**: 开发者无需关心底层服务器，专注于业务逻辑，按需执行代码。

---

## DNS

DNS（Domain Name System，域名系统）是互联网的一项核心服务，负责将人类可读的域名（如 `www.example.com`）转换为机器可识别的IP地址（如 `192.168.1.1`）。DNS 系统通过分层结构实现域名解析，主要包括 **Local DNS** 和 **权威 DNS**。

## Local DNS

### 功能

Local DNS（本地DNS）是用户设备与权威DNS之间的中间层，主要负责以下任务：
1. **接受和处理用户的DNS请求**  
   当用户在浏览器中输入一个域名时，Local DNS会接收并处理该请求。
   
2. **缓存DNS结果**  
   为了提高解析速度和减少网络流量，Local DNS会缓存之前查询到的DNS记录。如果缓存中存在对应的记录，则直接返回结果，无需向权威DNS查询。

3. **必要时向权威DNS查询**  
   如果缓存中没有对应的DNS记录，Local DNS会向权威DNS发起查询请求，获取最新的解析结果。

### 工作原理

1. 用户设备发起DNS请求，首先会发送到配置的Local DNS服务器（通常由ISP提供或自定义设置）。
2. Local DNS检查缓存中是否存在对应的DNS记录：
   - 如果存在且未过期，则直接返回缓存结果。
   - 如果不存在或已过期，则向根DNS服务器、顶级域DNS服务器（TLD）以及权威DNS服务器逐级查询，最终获取解析结果。
3. 将解析结果返回给用户设备，并将其缓存以备后续使用。


## 权威 DNS

### 功能

权威DNS（Authoritative DNS）是域名解析的最终来源，存储和提供特定域名的DNS记录。它的主要功能包括：
1. **存储域名的DNS记录**  
   权威DNS服务器保存了特定域名的所有DNS记录，包括A记录（IPv4地址）、AAAA记录（IPv6地址）、CNAME记录（别名）、MX记录（邮件服务器）等。

2. **作为域名解析的最终来源**  
   当Local DNS无法从缓存中获取解析结果时，会向权威DNS查询，权威DNS返回的记录是域名解析的权威答案。

### 工作原理

1. 权威DNS服务器由域名所有者或其托管服务商管理，负责维护域名的DNS记录。
2. 当Local DNS向权威DNS发起查询时，权威DNS会根据请求的域名返回对应的DNS记录。
3. 权威DNS不会缓存其他域名的记录，仅负责提供自身管理的域名解析信息。

---

## 文件系统-Blob模式

Glob 是一种用于匹配文件路径的模式语言，广泛应用于文件搜索、构建工具（如 Webpack、ESLint）以及脚本中。它通过简单的通配符和模式表达式，能够快速定位符合特定规则的文件。

常见的通配符包括：
- `*`：匹配任意数量的字符（不包括路径分隔符 `/`）。
- `**`：匹配任意数量的字符（包括路径分隔符 `/`）。
- `?`：匹配单个字符。
- `[]`：匹配括号内的任意一个字符。
- `{}`：匹配大括号内的任意一个模式（逗号分隔）。
- `@()`：匹配括号内的任意一个模式（管道符分隔）。

---

## 特殊语法解析

### @() 语法

`@()` 是 Glob 模式中的一种高级语法，用于匹配括号内用管道符 `|` 分隔的多个模式之一。它的作用类似于正则表达式中的 `(pattern1|pattern2)`。

#### 语法格式
```bash
@(<pattern1>|<pattern2>|...)
```

- `@()` 中的每个模式可以是文件名、扩展名或路径的一部分。
- 匹配时，只要文件路径符合括号内的任意一个模式即可。

---

## 示例解析

以下是一个具体的 Glob 模式示例及其解析：

```bash
eslint '@(src|docs)/**/*.@(js|jsx|md)'
```

### 解析
1. **`@(src|docs)`**  
   匹配 `src` 或 `docs` 文件夹。  
   - `src` 和 `docs` 是两个备选路径。
   - 只有这两个文件夹下的内容会被匹配。

2. **`/**/`**  
   匹配任意层级的子目录。  
   - `**` 表示递归匹配所有子目录。
   - 例如，`src/utils/helper.js` 和 `docs/guide/README.md` 都会被匹配。

3. **`*.@(js|jsx|md)`**  
   匹配以 `.js`、`.jsx` 或 `.md` 结尾的文件。  
   - `*` 表示文件名部分可以是任意字符。
   - `.@(js|jsx|md)` 表示文件扩展名必须是 `js`、`jsx` 或 `md`。

### 匹配结果
假设项目结构如下：
```
project/
├── src/
│   ├── index.js
│   ├── utils/
│   │   └── helper.jsx
├── docs/
│   ├── README.md
│   └── guide/
│       └── tutorial.md
├── test/
│   └── example.js
```

运行上述命令后，匹配到的文件为：
- `src/index.js`
- `src/utils/helper.jsx`
- `docs/README.md`
- `docs/guide/tutorial.md`

注意：`test/example.js` 不会被匹配，因为它不在 `src` 或 `docs` 文件夹下。

---

## linux


## Terminal 翻页快捷键

在终端中查看长输出内容时，可以使用以下快捷键进行翻页：

- **向上翻页**：`Ctrl + b`
- **向下翻页**：`空格键`

> **补充说明**：
>
> - 这些快捷键通常用于 `less` 或 `more` 命令的分页查看模式。
> - 如果需要退出分页模式，可以按 `q` 键。

## Linux 命令行帮助工具

### TLDR Pages

TLDR 是一个简化版的命令行帮助工具，提供常用命令的简洁示例和说明，适合快速查阅。

- **项目地址**：[https://github.com/tldr-pages/tldr](https://github.com/tldr-pages/tldr)
- **安装方法**：
  ```bash
  # 使用 npm 安装
  npm install -g tldr

  # 或者使用包管理器（例如 Homebrew）
  brew install tldr
  ```
- **使用示例**：
  ```bash
  tldr tar
  ```
  输出示例：
  ```plaintext
  tar

  Archiving utility.
  Often combined with a compression method, such as gzip or bzip2.

  - Create an archive from files:
    tar cf target.tar file1 file2 file3

  - Extract an archive in a specific directory:
    tar xf source.tar -C directory
  ```

> **特点**：
>
> - 提供简明扼要的命令示例，避免冗长的官方文档。
> - 支持多种操作系统和语言。


## 将 Web 应用打包成客户端

### Pake 工具

Pake 是一个开源工具，可以将 Web 应用快速打包为桌面客户端，支持跨平台运行。

- **项目地址**：[https://github.com/tw93/Pake](https://github.com/tw93/Pake)
- **功能特点**：
  - 支持将任意网页封装为桌面应用。
  - 提供自定义窗口、图标等功能。
  - 支持 Windows、macOS 和 Linux 平台。
- **安装与使用**：
  ```bash
  # 克隆项目
  git clone https://github.com/tw93/Pake.git

  # 安装依赖
  cd Pake
  npm install

  # 打包 Web 应用
  npm run build --url=https://example.com --name=MyApp
  ```
- **参数说明**：
  - `--url`：指定要打包的网页地址。
  - `--name`：指定生成的应用名称。

> **应用场景**：
>
> - 将常用的在线工具（如 Notion、Trello）封装为桌面客户端。
> - 快速构建轻量级桌面应用原型。



## 常用工具与操作

### 查看用户操作记录
- **`history` 工具**  
  - 用于查看用户在电脑上的操作记录。  
  - 示例：`history` 命令会列出当前用户的命令历史。

### 检查端口是否有服务
- 使用 `telnet` 检查目标 IP 和端口是否开放：
  ```bash
  telnet 1.1.1.1 1232
  ```
  - 如果连接成功，说明目标端口有服务运行。
  - 如果连接失败，可能是端口未开放或服务未启动。


## 经典面试题：`ping` 回车发生了什么？

当我们在终端输入 `ping <目标IP>` 并按下回车时，以下是完整的流程：

### 1. 查看路由表
- 使用 `route -n` 查看路由表：
  ```bash
  route -n
  ```
  - 路由表帮助定位数据包需要通过哪个网卡发送。

### 2. 查看网卡信息
- 使用 `ifconfig` 查看网卡信息：
  ```bash
  ifconfig
  ```
  - 确定当前网卡的子网掩码和 IP 地址范围。
  - 判断目标 IP 是否在当前子网内：
    - 如果目标 IP 在子网内，则直接通过 ARP 协议获取目标设备的 MAC 地址。
    - 如果目标 IP 不在子网内，则需要通过网关转发。

### 3. 获取目标 IP 的 MAC 地址
- 使用 `arp -a` 查看 ARP 缓存表：
  ```bash
  arp -a
  ```
  - ARP 协议负责将目标 IP 地址解析为对应的 MAC 地址。
  - 数据包的发送是基于 MAC 地址，而不是直接基于 IP 地址。

### 4. 抓包分析 ARP 请求
- 使用 `tcpdump` 抓取 ARP 请求：
  ```bash
  tcpdump -i eth0 arp
  ```
  - 分析 ARP 请求和响应过程，确认目标设备的 MAC 地址。


### 5. 域名解析（如果目标是域名）
- 如果目标是一个域名（如 `www.example.com`），需要先进行域名解析：
  - **`gethostbyname` 函数**  
    - 通过 glibc 的 `gethostbyname` 函数解析域名。
    - 解析顺序由 `/etc/nsswitch.conf` 文件决定：
      - 先检查 `/etc/hosts` 文件。
      - 再查询 DNS 服务器。
  - **`nslookup` 工具**  
    - 直接从 `/etc/resolv.conf` 中读取 `nameserver` 配置。
    - 不调用 `gethostbyname`，也不检查 `/etc/hosts` 或 `/etc/nsswitch.conf`。


### 6. 发送 ICMP 包
- `ping` 使用 ICMP 协议发送请求包：
  - 构造一个 ICMP Echo Request 数据包。
  - 数据包通过网卡发送到目标设备。
- 目标设备收到后返回 ICMP Echo Reply 数据包。


## UDP 应用：DNS 协议
- DNS 查询通常使用 UDP 协议（端口 53）。
- 流程：
  1. 客户端向 DNS 服务器发送查询请求。
  2. DNS 服务器返回解析结果。


## 调试工具：`strace` 和抓包
- **`strace` 命令**  
  - 用于跟踪系统调用和信号。
  - 示例：跟踪 `ping` 命令的系统调用：
    ```bash
    strace ping www.example.com
    ```
- **抓包工具**  
  - 使用 `tcpdump` 或 `Wireshark` 抓取网络流量，分析数据包内容。
  - 示例：抓取 ICMP 数据包：
    ```bash
    tcpdump -i eth0 icmp
    ```

---

## 函数式编程


## 函数式编程的特点

- **纯函数**: 函数的输出仅依赖于输入，无副作用。
- **不可变性**: 数据不可更改，通过创建新数据来实现状态变化。
- **高阶函数**: 函数可以作为参数传递或返回值，支持组合和复用。
- **工具方法**: 常用于编写通用工具函数，如数组操作、字符串处理等。

**典型应用场景**:
- React 组件中，函数式组件利用纯函数特性，确保组件的状态和行为可预测。
- 数据处理逻辑中，使用函数式编程简化复杂的数据流操作。

## 面向对象编程的特点

- **封装**: 将数据和行为封装到类中，隐藏内部实现细节。
- **继承**: 通过继承实现代码复用，减少重复代码。
- **多态**: 不同对象对同一消息做出不同的响应，增强灵活性。
- **建模能力**: 更适合对复杂系统进行抽象和建模。

**典型应用场景**:
- 框架设计中，使用 OOP 构建可复用的模块和组件。
- 复杂业务逻辑中，通过类和对象组织代码，提升可维护性。

## 函数式与面向对象的结合使用

### 结合原则
- **根据需求选择合适的方式**: 
  - 如果需要处理大量数据流或工具方法，优先考虑函数式编程。
  - 如果需要构建复杂的系统模型或框架，优先考虑面向对象编程。
- **混合使用**: 在一个项目中，可以根据不同模块的需求，灵活结合两种编程范式。

### 实际案例
1. **React 开发**:
   - 函数式组件利用纯函数特性，确保组件的行为可预测。
   - 状态管理库（如 Redux）中，使用函数式编程处理状态更新。
   - 在大型项目中，仍然可以通过类组件或 OOP 的方式组织复杂逻辑。

2. **Node.js 后端开发**:
   - 使用 OOP 构建服务层和模型层，便于复用和扩展。
   - 在工具函数中使用函数式编程，简化数据处理逻辑。

## 适用场景分析

### 函数式编程适用场景
- **工具函数**: 如日期格式化、字符串处理、数组操作等。
- **数据流处理**: 如 Redux 中的状态管理、RxJS 中的事件流处理。
- **UI 渲染**: React 函数式组件利用纯函数特性，确保 UI 渲染的一致性。

### 面向对象编程适用场景
- **框架设计**: 如 Express、Midway 等框架，使用 OOP 构建可扩展的模块。
- **复杂业务逻辑**: 如电商系统中的订单、支付、库存等模块，通过类和对象组织代码。
- **状态管理**: 如游戏开发中，使用 OOP 管理角色状态和行为。

---

## TCP

## RFC 1180 - TCP/IP 教程

### 概述
[RFC 1180](https://datatracker.ietf.org/doc/html/rfc1180?spm=ata.21736010.0.0.7fef5b82m2OFdt) 是一份经典的 TCP/IP 教程文档，由 IETF 发布，旨在帮助初学者理解 TCP/IP 协议栈的基本概念和工作原理。

### 主要内容
- **TCP/IP 基础**：介绍协议栈的分层结构（应用层、传输层、网络层、链路层）。
- **IP 协议**：详细讲解 IP 地址、子网划分、路由选择等内容。
- **TCP 和 UDP**：对比两种传输协议的特点及适用场景。
- **常见应用层协议**：如 HTTP、FTP、SMTP 等的工作机制。

### 阅读建议
- 适合对计算机网络有一定基础的读者。
- 结合实际网络环境进行实验验证，例如通过抓包工具观察协议交互过程。

## 《TCP/IP 卷》

《TCP/IP 卷》是一套经典的计算机网络书籍，深入剖析了 TCP/IP 协议栈的设计与实现细节。该系列书籍通常分为多卷，涵盖从基础理论到高级应用的全面内容。

## 《Wireless 抓包艺术》推荐

### 概述
《Wireless 抓包艺术》是一本专注于无线网络抓包技术的书籍，重点讲解如何利用抓包工具分析无线通信数据流，揭示隐藏在无线信号中的信息。

### 主要内容
- **无线网络基础**：包括 Wi-Fi、蓝牙等无线通信协议的基本原理。
- **抓包工具使用**：详细介绍 Wireshark、AirPcap 等工具的操作方法。
- **数据分析技巧**：如何解读抓包结果，识别异常流量或潜在安全威胁。
- **实战案例**：通过真实场景演示抓包技术的应用价值。

### 学习建议
- **熟悉基础知识**：在学习本书之前，建议先掌握基本的网络知识。
- **注重实操**：准备一台支持无线抓包的设备，边学边练。
- **关注安全性**：了解抓包可能涉及的法律和道德问题，避免滥用技术。

## TCP 三次握手

- Host1发送`SYN`，进入`SYN-SENT`状态。
   - **发起方（Host1）**向**接收方（Host2）**发送一个带有`SYN`标志的TCP报文段。这个报文段包含一个随机生成的初始序列号（ISN，Initial Sequence Number），用于标识后续数据流的起点。
- Host2收到`SYN`，进入`SYN-RECEIVED`状态，并发送`SYN-ACK`。
   - **接收方（Host2）**收到Host1的`SYN`报文后，会回复一个带有`SYN`和`ACK`标志的TCP报文段。
   - Host2也会生成自己的初始序列号（`y`），并通过`SYN`发送给Host1。
   - 同时，Host2通过`ACK`确认收到Host1的`SYN`，并将确认号设置为`x+1`（表示期望收到的下一个字节）。
   - 此时，Host2进入`SYN-RECEIVED`状态。
- Host1收到`SYN-ACK`，发送`ACK`，双方进入`ESTABLISHED`状态。
   - **发起方（Host1）**收到Host2的`SYN-ACK`报文后，会发送一个带有`ACK`标志的TCP报文段。
   - Host1将确认号设置为`y+1`，表示期望收到Host2的下一个字节。
   - 此时，Host1和Host2都进入`ESTABLISHED`状态，连接成功建立，可以开始数据传输。


### **总结三次握手的状态变化**
- **Host1**:
  1. 初始状态：`CLOSED`
  2. 发送`SYN`后：`SYN-SENT`
  3. 收到`SYN-ACK`后：`ESTABLISHED`

- **Host2**:
  1. 初始状态：`LISTEN`
  2. 收到`SYN`后：`SYN-RECEIVED`
  3. 收到`ACK`后：`ESTABLISHED`

### **为什么需要三次握手？**
1. **协商初始序列号**：
   - TCP使用序列号来保证数据包的顺序性和可靠性。三次握手允许双方交换各自的初始序列号，从而为后续的数据传输做好准备。

2. **防止历史连接的影响**：
   - 如果网络中存在延迟或重复的旧连接请求，三次握手可以检测到这些无效请求并丢弃它们，避免错误连接。

3. **双向确认**：
   - 确保双方都能正常收发数据。例如，Host1确认Host2能收到数据，Host2也确认Host1能收到数据。


## 四次挥手

- 第一次挥手：发送 FIN（主动关闭方发起）
   - Host1（主动关闭方）决定关闭连接，向Host2发送一个带有FIN标志的报文段。FIN表示“我已没有数据要发送了”。此时，Host1进入FIN-WAIT-1状态。
- 第二次挥手：发送 ACK（被动关闭方响应）
   - Host2收到Host1的FIN后，会回复一个带有ACK标志的报文段。
      - ACK确认号设置为x+1，表示已收到Host1的FIN。
      - 此时，Host2进入CLOSE-WAIT状态，而Host1进入FIN-WAIT-2状态。
      - 注意：此时Host2可能仍然有数据要发送给Host1，因此连接并未完全关闭。
- 第三次挥手：发送 FIN（被动关闭方发起）
   - 当Host2完成所有数据传输后，也会发送一个带有FIN标志的报文段，表示“我也已没有数据要发送了”。此时，Host2进入LAST-ACK状态。
- 第四次挥手：发送 ACK（主动关闭方响应）
   - Host1收到Host2的FIN后，会回复一个带有ACK标志的报文段。
   - ACK确认号设置为y+1，表示已收到Host2的FIN。
   - 此时，Host1进入TIME-WAIT状态，而Host2直接进入CLOSED状态。


## TIME-WAIT

在TCP连接关闭的过程中，当一方（例如Host1）发送最后一个`ACK`确认报文（第四次挥手）后，会进入`TIME-WAIT`状态。在此状态下，该方会等待一段时间（通常是**2倍的最大报文生存时间，2 * MSL**），然后才完全关闭连接。

- **MSL (Maximum Segment Lifetime)**：最大报文生存时间，表示一个TCP报文在网络中能够存在的最长时间。通常设置为2分钟，因此`TIME-WAIT`的时间通常是4分钟。

### 为什么需要 TIME-WAIT

#### **(1) 确保最后的 ACK 被接收**
在TCP连接关闭时，双方通过四次挥手（Four-Way Handshake）来终止连接。如果Host1发送的最后一个`ACK`丢失，Host2将无法确认连接已成功关闭，并会重新发送`FIN`消息。如果没有`TIME-WAIT`状态，Host1可能会直接关闭连接，导致Host2永远无法收到确认，从而陷入错误状态。

通过保持`TIME-WAIT`状态，Host1可以继续监听网络，如果收到Host2重发的`FIN`，可以再次发送`ACK`以完成连接关闭。

#### **(2) 清理网络中的延迟报文**
网络中可能存在延迟或重复的报文段（例如由于路由问题或网络拥塞）。如果连接立即关闭，这些滞留的报文可能会被误认为是新连接的一部分，从而导致数据混乱。

`TIME-WAIT`状态的存在确保了所有与当前连接相关的报文都能在网络中消失，避免它们干扰后续的新连接。

#### **(3) 避免旧连接的报文影响新连接**
TCP使用四元组（源IP、源端口、目标IP、目标端口）来标识一个连接。如果一个连接关闭后立即重新使用相同的四元组建立新连接，那么旧连接中滞留的报文可能会被误认为属于新连接，从而导致数据污染或协议错误。

通过等待`TIME-WAIT`时间，可以确保旧连接的所有报文都已过期，从而安全地复用四元组。

## 重传机制

TCP 使用确认机制（ACK）来确保数据包被成功接收。如果发送方在一定时间内未收到接收方的确认（ACK），就会触发重传机制。

- 超时重传（RTO, Retransmission Timeout）：
   - 发送方为每个数据包设置一个超时时间（RTO，Retransmission Timeout）。
   - 如果在 RTO 时间内未收到 ACK，发送方会重新发送该数据包。
- 快速重传（Fast Retransmit）：
   - 如果接收方检测到数据包丢失（例如收到乱序的数据包），会连续发送多个重复的 ACK。
   - 当发送方收到 3 个重复的 ACK 时，会立即重传丢失的数据包，而无需等待 RTO 超时。